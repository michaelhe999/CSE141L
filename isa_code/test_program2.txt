li 0000101 # Load 5 into R1 to get mem5
lw 1 2 # Load mem5 into R2
li 1111111 # Load all 1s into R1
move 1 0 # Move all 1s to R0
li 0000001 # Load 1 into R1
srl 0 1 # R1 is now 01111111
move 1 0 # Move 01111111 to R0
li 1111111 # Load all 1s into R1
xor 0 1 # R1 is now 10000000
and 1 2 # R1 = Sign
move 1 0 # R0 = Sign
li 0100000 # Put Sign into mem32
sw 1 0 # Sign is stored in mem32
li 1111100 # Load mask into R1
move 1 3 # Move mask into R3
li 0000001 # Load 1 into R1 for shifting
move 1 0 # Move 1 into R0
sll 3 0 # Remove first bit of mask
srl 1 0 # Mask is now 01111100 
and 1 2 # Get Exp from MSW
move 1 0 # R0 = Exp
li 0100001 # Put Exp into mem33
sw 1 0 # Exp is stored in mem33
li 0000010 # Put 2 into R1 for shifting
srl 0 1 # Shift Exp right by 2
move 1 3 # Move Exp >> 2 into R3
li 0010111 # Load 23 into R1
slt 1 3 # R1 = 0 when Exp >> 2 < 23; this branches to the case where exp <= 22
beq 0100101 # 37; (exp <= 22)
li 1111111 # Load all 1s into R1
move 1 0 # Move all 1s to R0
li 0000001 # Load 1 into R1
srl 0 1 # R1 is now 01111111
move 1 0 # Move 01111111 into R0
li 0000111 # Load 7 into R1
sw 1 0 # Store 01111111 into mem7 (max case; temp)
li 1111111 # Load all 1s into R1
move 1 0 # Move all 1s to R0
li 0000110 # Load 6 into R1
sw 1 0 Store 11111111 into mem6 (max case; temp)
li 0100000 # Load 32 into R1
lw 1 1 # Load Sign into R1
beq 0001110 # 14; (Finished with max case)
li 1111111 # Handle negative max cases; XOR mask
move 1 0 # Move XOR mask into R0
li 0000111 # Load 7 into R1; get mem7
lw 1 1 # Load mem7 into R1
xor 0 1 # Flip mem7
move 1 2 # Move flipped mem7 into R2
li 0000111 # Mem 7
sw 1 2 # Store flipped mem7
li 0000110 # Load 6 into R1; get mem6
lw 1 1 # Load mem6 into R1
xor 0 1 # Flip mem6
move 1 2 # Move flipped mem6 into R2
li 0000110 # Mem 6
sw 1 2 # Store flipped mem6
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
done
li 0000110 # max case is handled, now handle min cases; Load 7 into R1
slt 1 3 # if exp >= 7, branch (R1 = 0) -> R1 = 7 < exp 
beq 0001111 # 15; (exp >= 7)
li 0000000 # Handle 0s cases; Load 0 into R1
move 1 0 # R0 is 0
li 0000111 # Address 7
sw 1 0 # Store 0s into mem7
li 0000110 # Address 6
sw 1 0 # Store 0s into mem6
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
done
li 0000101 # BRANCH DESTINATION FOR HARD CASES; Load 5 into R1
lw 1 0 # Load mem5 into R0
li 0000111 # Load 7 into R1
sw 1 0 # Store mem5 into mem7
li 0000100 # Load 4 into R1
lw 1 0 # Load mem4 into R0
li 0000110 # Load 6 into R1
sw 1 0 # Store mem4 into mem6
li 0010001 # EXP IS BETWEEN 22 AND 7 (INCLUSIVE); Load 17 into R1
move 1 2 # Move counter to R2
li 0010001 # Load 16 into R1
slt 1 3 # If 16 < exp, R1 = 1; if exp <= 16, R1 = 0
beq 0100111 # 39; (handle right shifting)
li 0010001 # Load 17 into R1
neq 1 3 # If exp != 17, R1 = 1; else exp = 17, R1 = 0
beq 0100111 # 39; CHAIN (handle equal case)
li 0010111 # Handle left shift loop here; Load 23 into R1
move 1 3 # R3 is our limit of 23
li 0010001 # Load 17 into R1
move 1 2 # R2 is our counter; starts at 17 and increments 
{
    slt 2 3 # If counter is >= our upper bound, break out of loop
    beq 0100001 # 33; (loop end; should be the same as equal case) 
    li 0000110 # Load 6 into R1
    lw 1 0 # Load mem6 into R0
    li 0000001 # Load 1 into R1 for shifting
    sll 0 1 # Shift mem6 left by 1 
    move 1 0 # Shifted mem6 in R0
    li 0100010 # Store temp shifted mem6 in mem34
    sw 1 0 # temp shifted mem6 in mem34
    li 0000111 # Load 7 into R1
    lw 1 0 # Load mem7 into R0
    li 0000001 # Load 1 into R1 for shifting
    sll 0 1 # Shift mem7 left by 1
    move 1 0 # move shifted mem7 to R0
    li 0000110 # Load 6 into R1
    lw 1 3 # Load mem6 into R3
    li 0000111 # Load 7 into R1
    srl 3 1 # Shift mem6 right 7
    xor 0 1 # Combine 1 shifted mem7 and MSW of mem6 
    move 1 0 # Move that into R0
    li 0000111 # Load 7 into R1
    sw 1 0 # Load updated mem7 into mem7
    li 0100010 # Load 34 into R0 
    lw 1 0 # Load temp shifted mem6 into R0
    li 0000110 # Load 6 into R1
    sw 1 0 # Store shifted mem6 into mem6
    li 0010111 # Load 23 into R1
    move 1 3 # Load 23 back into R3
    li 0000001 # Load 1 to R1 to increment
    add 1 2 # Increment counter
    li 0000000 # Load 0 into R1 for branching
    beq 1100000 # -32; (start of loop) # - ;
}
li 0000110 # BRANCH HERE TO HANDLE right shift loop here; Load 6 into R1
move 1 3 # R3 is our limit of 6
li 0010001 # Load 17 into R1
beq 0100001 # 33; CHAIN TO CHECK NEGATIVE
move 1 2 # R2 is our counter; starts at 17 and decrements 
{
    slt 3 2 # If our lower bound is >= counter is, break out of loop
    beq 0011110 # 30; (loop end; should be the same as equal case) 
    li 0000111 # Load 7 into R1
    lw 1 0 # Load mem7 into R0
    li 0000001 # Load 1 into R1 for shifting
    srl 0 1 # Shift mem7 right by 1 
    move 1 0 # Shifted mem7 in R0
    li 0100010 # Store temp shifted mem7 in mem34
    sw 1 0 # temp shifted mem7 in mem34
    li 0000110 # Load 6 into R1
    lw 1 0 # Load mem6 into R0
    li 0000001 # Load 1 into R1 for shifting
    srl 0 1 # Shift mem6 right by 1
    move 1 0 # move shifted mem6 to R0
    li 0000111 # Load 7 into R1
    lw 1 3 # Load mem7 into R3
    li 0000111 # Load 7 into R1
    sll 3 1 # Shift mem7 left 7
    xor 0 1 # Combine 1 shifted mem6 and LSW of mem7 
    move 1 0 # Move that into R0
    li 0000110 # Load 6 into R1
    sw 1 0 # Load updated mem6 into mem6
    li 0100010 # Load 34 into R0 
    lw 1 0 # Load temp shifted mem7 into R0
    li 0000111 # Load 7 into R1
    sw 1 0 # Store shifted mem7 into mem7
    li 0000110 # Load 6 into R1
    move 1 3 # Load 6 back into R3
    li 1111111 # Load -1 to R1 to decrement
    add 1 2 # Decrement counter
    li 0000000 # Load 0 into R1 for branching
    beq 1100000 # (start of loop) # -32;
}
li 0100000 # Handle the negative case; Get mem32
lw 1 0 # Store Sign in R0
li 0000111 # Load 7 into R1 for shifting
srl 0 1 # R1 = R0 >> 7
move 1 0 # R0 = sign bit (0 or 1)
li 0000000 # Load 0 into R1
neq 0 1 # if sign bit (R1) != 0, R1 = 1; if sign bit == 0, then R1 = 0 (branch to the positive case)
beq 0010110 # 22; Done!
li 1111111 # Mask 
move 1 0 # Move mask to R0
li 0000110 # mem6
lw 1 2 # mem6 into R2
xor 0 2 # R1 = flipped R1
move 1 2 # move flipped into R2
li 0000001 # Load 1 into R1 to add
over 1 2 # Check if overflow from adding 1 to R2
move 1 3 # Move overflow into R3
li 0000001 # Load 1 into R1 to add
add 1 2 # Add 1 to R2
move 1 2 # Move to R2
li 0000110 # mem6
sw 1 2 # Store mem6
li 0000111 # mem7
lw 1 2 # mem7 into R2
xor 0 2 # R1 = flipped R1
move 1 2 # move flipped into R2
add 1 3 # add possible overflow to flipped
move 1 2 # move to R2
li 0000111 mem7 
sw 1 2 # Store mem7 
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
li 0000000 # NOP
done